(ns xp.metacols
  (:refer-clojure :exclude [extend get])
  (:require [clojure.core :as c]
            [monk.vec :as vec]
            [monk.utils :as u :refer [pp ppx]])
  (:import (clojure.lang Symbol Keyword MapEntry IPersistentVector IPersistentMap ISeq IPersistentSet Fn)))



(def ->class

  ;; simple alias map to common classes

  {:vec   IPersistentVector
   :map   IPersistentMap
   :seq   ISeq
   :set   IPersistentSet

   :entry MapEntry

   :num   Number
   :key   Keyword
   :sym   Symbol
   :str   String

   :fun   Fn})

(def operations
  (atom #{}))

(defmacro extend [name pat & body]
  (let [method-sym (u/mksym name "_method")
        classes (map #(->class % %) (take-nth 2 body))
        impls (map #(list method-sym pat %) (take-nth 2 (next body)))]
    `(do (extend-protocol ~(u/mksym name "_proto")
           ~@(interleave classes impls)))))

(defmacro defm [name pat & body]

  (let [arity (count pat)
        protocol-sym (u/mksym name "_proto")
        ;; method-sym (u/mksym name "_method")
        typeclass-sym (u/mksym "i" name)
        qualified-sym (u/mksym (str *ns*) "/" name)
        guard-sym (u/mksym typeclass-sym "?")

        [impls default]
        (if (odd? (count body))
          [(butlast body) (last body)]
          [body nil])

        declaration
        `(do (defprotocol ~protocol-sym
               :extend-via-metadata true
               (~name ~pat))
             (swap! operations conj ~(keyword (str typeclass-sym))))

        extension
        (macroexpand-1 `(extend ~name ~pat ~@impls))

        default-extension
        `(extend-protocol ~protocol-sym Object (~name ~pat ~default))

        reduction
        (when (= 2 arity)
          (let [varg-sym (gensym "more_")]
            `(defn ~(u/mksym name ">") ~(conj pat '& varg-sym)
               (reduce ~name ~(cons name pat) ~varg-sym))))

        argumentation
        (when (> arity 1)
          `(defn ~(u/mksym name "_") ~(vec (next pat))
             (fn [~(first pat)] (~name ~@pat))))

        meta-extension
        `(defn ~typeclass-sym [x# f#]
           (vary-meta x# assoc '~qualified-sym f#))

        guard
        `(defn ~guard-sym [x#]
           (when (satisfies? ~protocol-sym x#) x#))

        ]

    `(do ~declaration
         ~extension
         ~default-extension
         ~reduction
         ~argumentation
         ~meta-extension
         ~guard)))

(defmacro i [x & impls]
  `(-> ~x ~@(map (fn [[name & body]]
                   (list (u/mksym "i" name) (cons `fn body)))
                 impls)))


(defm getter [x])

(defm get [x y]
      :vec (vec/get x y)
      :map (c/get x y)
      ((getter y) x))

(defm checker [x])
(defm check [x y] ((checker y) x))

(defm updater [x])
(defm upd [x y] ((updater y) x))

(i {:foo :bar}
   (get [_ y] :always-foo-bro)
   (upd [x f] x)
   (check [_ y] (when (:foo y) :yo-bro)))


;; combination , function of 2 arguments

;; each argument can have its implementation
(defm comb1 [x y] x)

(defm comb2 [y x] nil)

;; the second argument has precedence over the first
(defm comb [x y]
      (or (comb2 y x)
          (comb1 x y)))

;; one other way is to do this

;; each argument can cast himself depending on the other argument
(defm comb-a1 [x y] x) ;; 1st argument
(defm comb-a2 [y x] y) ;; 2nd argument
(defm comb-i2 [y x] (comb-a1 x y)) ;; reversed combination
(defm comb-i1 [x y] x) ;; combination
(defn comb [x y]
  (let [x (comb-a1 x y)
        y (comb-a2 y x)]
    (or (comb-i2 y x)
        (comb-i1 x y))))

;; this code should be generated by
'(defc comb [a b])

;or could exand to this instead

(defm comb-cast2 [y x])
(defm comb-cast1 [x y] (comb-cast2 y x))
(defm comb-call2 [y x])
(defm comb-call1 [x y] (comb-call2 y x))


;; combination

(defn comb [x y]
  (or (comb-call1 x y)
      (when-let [[x' y'] (comb-cast1 x y)]
        (when-not (= [x y] [x' y'])
          (comb x' y')))))

(comment

 ;; we can even handle if we want
 `(defc comb [a b c])

 (defm comb-a1 [x y z] (comb-a2 y x z))
 (defm comb-a2 [y x z] (comb-a3 z x y))
 (defm comb-a3 [z x y])
 (defm comb-i1 [x y z] (comb-i2 y x z))
 (defm comb-i2 [y x z] (comb-i3 z x y))
 (defm comb-i3 [z x y])

 ;; combination

 (defn comb [x y z]
   (or (comb-i1 z x y)
       (when-let [[x' y' z'] (comb-a1 x y z)]
         (comb x' y' z')))))

(extend )




