(ns xp.metacols
  (:refer-clojure :exclude [extend get])
  (:require [clojure.core :as c]
            [monk.vec :as vec]
            [monk.utils :as u :refer [pp ppx]])
  (:import (clojure.lang Symbol Keyword MapEntry IPersistentVector IPersistentMap ISeq IPersistentSet Fn)))



(def ->class

  ;; simple alias map to common classes

  {:vec   IPersistentVector
   :map   IPersistentMap
   :seq   ISeq
   :set   IPersistentSet

   :entry MapEntry

   :num   Number
   :key   Keyword
   :sym   Symbol
   :str   String

   :fun   Fn})

(def operations
  (atom #{}))

(defmacro extend [name pat & body]
  (let [classes (map #(->class % %) (take-nth 2 body))
        impls (map #(list name pat %) (take-nth 2 (next body)))]
    `(do (extend-protocol ~(u/mksym name "_proto")
           ~@(interleave classes impls)))))

(defmacro defm [name pat & body]

  (let [arity (count pat)
        protocol-sym (u/mksym name "_proto")
        typeclass-sym (u/mksym "i" name)
        qualified-sym (u/mksym (str *ns*) "/" name)
        guard-sym (u/mksym typeclass-sym "?")

        [impls default]
        (if (odd? (count body))
          [(butlast body) (last body)]
          [body nil])

        declaration
        `(do (defprotocol ~protocol-sym
               :extend-via-metadata true
               (~name ~pat))
             (swap! operations conj ~(keyword (str typeclass-sym))))

        extension
        (macroexpand-1 `(extend ~name ~pat ~@impls))

        default-extension
        `(extend-protocol ~protocol-sym Object (~name ~pat ~default))

        reduction
        (when (= 2 arity)
          (let [varg-sym (gensym "more_")]
            `(defn ~(u/mksym name ">") ~(conj pat '& varg-sym)
               (reduce ~name ~(cons name pat) ~varg-sym))))

        argumentation
        (when (> arity 1)
          `(defn ~(u/mksym name "_") ~(vec (next pat))
             (fn [~(first pat)] (~name ~@pat))))

        meta-extension
        `(defn ~typeclass-sym [x# f#]
           (vary-meta x# assoc '~qualified-sym f#))

        guard
        `(defn ~guard-sym [x#]
           (when (satisfies? ~protocol-sym x#) x#))

        impl-getter
        `(defn ~(u/mksym name "-impl") [x#]
           (some-> x# meta (get ~qualified-sym)))

        ]

    `(do ~declaration
         ~extension
         ~default-extension
         ~reduction
         ~argumentation
         ~meta-extension
         ~guard
         ~impl-getter)))

(defmacro i [x & impls]
  `(-> ~x ~@(map (fn [[name & body]]
                   (list (u/mksym "i" name) (cons `fn body)))
                 impls)))

(do :basics

    (defm getter [x])

    (defm get [x y]
          :vec (vec/get x y)
          :map (c/get x y)
          ((getter y) x))

    (defm checker [x])
    (defm check [x y] ((checker y) x))

    (defm updater [x])
    (defm upd [x y] ((updater y) x))

    (i {:foo :bar}
       (get [_ y] :always-foo-bro)
       (upd [x f] x)
       (check [_ y] (when (:foo y) :yo-bro))))

(do :combinations-taughts


    ;; combination , function of 2 arguments

    ;; each argument can have its implementation
    (defm comb1 [x y] x)

    (defm comb2 [y x] nil)

    ;; the second argument has precedence over the first
    (defm comb [x y]
          (or (comb2 y x)
              (comb1 x y)))

    ;; one other way is to do this

    ;; each argument can cast himself depending on the other argument
    (defm comb-a1 [x y] x) ;; 1st argument
    (defm comb-a2 [y x] y) ;; 2nd argument
    (defm comb-i2 [y x] (comb-a1 x y)) ;; reversed combination
    (defm comb-i1 [x y] x) ;; combination
    (defn comb [x y]
      (let [x (comb-a1 x y)
            y (comb-a2 y x)]
        (or (comb-i2 y x)
            (comb-i1 x y))))

    ;; this code should be generated by
    '(defc comb [a b])

    ;or could exand to this instead

    (defm comb-cast2 [y x])
    (defm comb-cast1 [x y] (comb-cast2 y x))
    (defm comb-call2 [y x])
    (defm comb-call1 [x y] (comb-call2 y x))


    ;; combination

    (defn comb [x y]
      (or (comb-call1 x y)
          (when-let [[x' y'] (comb-cast1 x y)]
            (when-not (= [x y] [x' y'])
              (comb x' y')))))

    (comment

     ;; we can even handle if we want
     `(defc comb [a b c])

     (defm comb-a1 [x y z] (comb-a2 y x z))
     (defm comb-a2 [y x z] (comb-a3 z x y))
     (defm comb-a3 [z x y])
     (defm comb-i1 [x y z] (comb-i2 y x z))
     (defm comb-i2 [y x z] (comb-i3 z x y))
     (defm comb-i3 [z x y])

     ;; combination

     (defn comb [x y z]
       (or (comb-i1 z x y)
           (when-let [[x' y' z'] (comb-a1 x y z)]
             (comb x' y' z'))))))



(do :interfaces?

    (definterface Igreet (greet []))

    #_(extend-type clojure.lang.PersistentVector
        Igreet
        (greet [x] "greet-vec"))

    (defm foo [x]
          Igreet (.greet x)
          :vec (mapv foo x)
          x)

    (deftype Pouet [x y]
      Igreet
      (greet [_] "greet!"))

    (defrecord Pouet2 [x y]
      Igreet
      (greet [_] "greet!"))

    (foo (Pouet2. 1 2)))

(do :tuples
    (defmacro deftup [name pat & impls]
      (let [argv (mapv (fn [i] (u/mksym "arg_" (str (inc i))))
                       (range (count pat)))]
        `(defn ~name ~argv
           (let ~(vec (interleave pat argv))
             (i ~argv
                ~@(map (fn [[n p & bod]] (list* n (vec/cat [pat] p) bod)) impls))))))

    (deftup pair [l r]
            (get [x] (case x :l l :r r)))

    (get (pair 1 2) :l)

    (let [p (pair 1 2)
          v [1 2]]
      (time (dotimes [_ 100000] (get p :r)))
      (time (dotimes [_ 100000] (get v -1))))

    (get (conj (pair 1 2) 3) :l)

    (foo (merge (ifoo (array-map)
                      (fn [x] "foo"))
                (apply hash-map (range 100)))))


(do :again

    ;; idea:
    ;; put the prototype of each clojure builtin type into the metadata of its 'zero' value

    ;; some basic generic functions that works on every types

    (defm get [x y])
    (defm put [x y z])
    (defm upd [x y z])

    (defm sip [x y])
    (defm cat [x y])

    (defm void [x])
    (defm vals [x])
    (defm idxs [x])
    (defm iter [x])
    (defm size [x])

    (def vec0
      (i []
         (get [v i] (vec/get v i))
         (put [v i x] (vec/put v i x))
         (upd [v i f] (vec/upd v i f))

         (sip [v x] (conj v x))
         (cat [v x] (into v (vals x))) ;; this is discutable...

         (void [_] vec0)
         (vals [v] (seq v))
         (size [v] (count v))
         (idxs [v] (range (size v)))
         (iter [v] (interleave (idxs v) (vals v)))))

    (defn vec [& xs]
      (reduce sip vec0 xs))

    (sip vec0 1)
    (put (sip vec0 1) 0 9)

    (size (put (vec 1 2 3) 1 :op))

    ()

    )

(do :protocols-expansion
    (pp (clojure.walk/macroexpand-all '(defprotocol Iop :extend-via-metadata true (iop [x]))))
    (do
      (let*
       [v__6729__auto__ (def Iop)]
        (if (. v__6729__auto__ hasRoot) nil (do (def Iop {}))))
      xp.metacols.Iop
      (clojure.core/alter-meta! #'Iop clojure.core/assoc :doc nil)
      (#'clojure.core/assert-same-protocol #'Iop '(iop))
      (clojure.core/alter-var-root
       #'Iop
       clojure.core/merge
       (clojure.core/assoc
        {:on 'xp.metacols.Iop, :on-interface xp.metacols.Iop}
         :sigs
         '{:iop {:name iop, :arglists ([x]), :doc nil}}
         :var
         #'Iop
         :method-map
         {:iop :iop}
         :method-builders
         {(clojure.core/intern
           clojure.core/*ns*
           (clojure.core/with-meta
            'iop
            (clojure.core/merge
             '{:name iop, :arglists ([x]), :doc nil}
             {:protocol #'Iop})))
          (fn*
            ([cache__7937__auto__]
             (let*
              [G__3502
               (fn* ([gf__x__3503] (. gf__x__3503 (iop))))
               f__7938__auto__
               (fn*
                 G__3501
                 ([gf__x__3504]
                  (let*
                   [cache__7935__auto__
                    (. G__3501 __methodImplCache)
                    f__7936__auto__
                    (.
                     cache__7935__auto__
                     fnFor
                     (. clojure.lang.Util classOf gf__x__3504))]
                    (if
                     f__7936__auto__
                      (f__7936__auto__ gf__x__3504)
                      ((clojure.core/-cache-protocol-fn
                        G__3501
                        gf__x__3504
                        xp.metacols.Iop
                        G__3502)
                       gf__x__3504)))))]
               (set! (. f__7938__auto__ __methodImplCache) cache__7937__auto__)
               f__7938__auto__)))}))
      (clojure.core/-reset-methods Iop)
      'Iop))